//时间安排问题是指一段时间内有n个不同活动,它们所占用时间段连续且是总时间段的子集,要求举行任何一场活动时不能有活动冲突,我们进行活动选择的问题
//我们先来一种最简单的问题,0~16的时间段办活动,怎么办的活动最多?
//我们要进行贪心策略会有很多种想法,比如找所占活动最短的,开始时间最早的,结束时间最早的
//这三种方法都有可能是正确的,所以贪心策略验证才是最关键的
//这时候我们可以尝试找反例来判断哪种策略是不对的
//(1)找时间占用最短的反例
//|---------| |--------|
//	  ①		|-|	   ②
//			 ③
//时间段轴:
//0 1 2 3 4 5 6 7 8 9 10
//----------------------->
//由上面的图我们可以看出,选最短的③反而导致了选的少了,选①②才是最优解,所以该策略是错误的

//(2)找开始时间早的反例
//|--------------------|
//			①
//  |--------| |-------|
//		③		   ④
//0 1 2 3 4 5 6 7 8 9 10
//----------------------->
//由上图可知,该策略也是错的

//(3)找结束时间最早的
//找啊找,找不到,那很奇怪了,不会是正确的策略吧
//没错,真是正确的
//我们假设有一种最优解,他有的活动与当前策略是相同的,有些策略是不同的
//要是相同我们就不管了
//但是要是不同的,那它的结束时间不会比我的这种策略早,只会晚,而且晚了也不能造成时间冲突
//所以我的策略与这种"最优解"可能有不同,且不同项的结束时间不比我早那就不可能剩的时间多,不可能剩的时间多挤出来几项

//现在来代码实现
//我们只需要先按结束时间升序,遍历一下,找最早结束的,时间冲突的不管即可

#include<iostream>
using namespace std;
int main()
{
	int start[11] = { 1,3,0,4,3,5,6,8,8,2,12 };
	int final[11] = { 4,5,6,7,9,9,10,11,12,14,16 };
	int launch[11] = {0};
	launch[0] = 1;
	int index_i = 0;
	int index_j = 1;
	while (index_j <= 10)
	{
		if (final[index_i] <= start[index_j])
		{
			launch[index_j] = 1;
			index_i = index_j++;
		}
		else
		{
			launch[index_j] = 0;
			index_j++;
		}
	}
	cout<<"举行的节目有：";
	for (int i = 0; i < 11; i++)
	{
		if (launch[i] == 1)
		{
			cout << i + 1 << ' ';
		}
	}
	return 0;
}
