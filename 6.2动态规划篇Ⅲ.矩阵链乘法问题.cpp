//矩阵链乘法问题是探究一堆矩阵连乘计算次数最短的策略
//而计算次数的多少与矩阵如何结合(结合律)有关
//比如三个规模为[40,8][8,30][30,5]的矩阵相乘,怎样结合算的次数最少
//前两个结合,则计算次数为40*8*30+40*30*5=15600
//后两个结合,则计算结果为40*8*5+8*30*5=2800
//可见结合顺序与计算结果之间差异显著

//那么我们现在进行动态规划四部曲
//1.问题构建.有一个长度为L的矩阵链,要求最少的计算次序以及如何结合,也就是括号加在哪里
//2.递推关系构建.我们认为要求的最优结果为Memo[i,j]那么我们加两组括号将这个问题分解时,就要面对三个变量i,j,k
//象征着(Pi,...,Pk)(Pk+1,....,Pj)
//那么Memo[i,j]=min(Memo[i,k]+Memo[k+1,j]+p[i-1]*p[k]*p[j]);	其中i<=k<=j-1;
//为什么是p[i-1],因为p记录的是i-j个矩阵的规格数,那么这个数字一共有j-i+1个,用p[i-1]就可以得到最左边元素的行规格
//但这也要求了p是从p[0]初始化的
//*******************/
//3.自底向上计算.
//首先,由于i<=j,所以Memo和Rec数组我们只用了一半
//其次,当i=j时,Memo[i,j]=0;因为此时矩阵链只有一个矩阵,根本不用算;
//最重要的,自底向上的方向
//由于我们只知道对角线方向,所以我们不是按i一层一层走的,而是沿着对角线方向逐渐收缩的!!!!!
//也就是长度为1时,走Memo[1][1],Memo[2][2],Memo[3][3]..(但实际上长度为1不用走)
//长度为2时,走Memo[1][2],Memo[2][3],Memo[3][4]
//所以遍历逻辑和len和i有关,其中j=len+i-1
//4.最优方案追踪
//追踪本质上是Rec[i,j]记录k的值这样我们就知道了两个括号加在哪里
//这里使用递归就可以左右两部分加上想要的括号了

#include<iostream>
using namespace std;
int Memo[1000][1000];
int Rec[1000][1000];
int p[1000];
void createMemoandRec(int L)
{
	for (int len = 2; len <= L; len++)
	{
		for (int i = 1; i <= L - len + 1; i++)
		{
			int j = i + len - 1;
			Memo[i][j] = INT_MAX;			//这里初始化Memo[i][j],而不是先定一个k的值,因为Memo这时候大把空白

			// 遍历所有可能的分割点k
			for (int k = i; k < j; k++)
			{
				int cost = Memo[i][k] + Memo[k + 1][j] + p[i - 1] * p[k] * p[j];
				if (cost < Memo[i][j])
				{
					Memo[i][j] = cost;
					Rec[i][j] = k;
				}
			}
		}
	}
}
void printresult(int i,int j)
{
	if (i == j)
	{
		cout << 'U' << i;	//5.3	出口这里才要打印Ui,递归的逻辑你还是多看多学吧
		return;
	}
	cout << '(';
	printresult(i,Rec[i][j]);
	//cout << ')' << '(';		中间这个不用加,这个递归函数可以看成两个整体,也可以极端点,只是两个矩阵,两个矩阵就没必要再单独画个括号了吧
	printresult(Rec[i][j] + 1, j);
	cout << ')';
}
int main()
{
	int L;
	cin >> L;
	for (int i = 0; i <= L; i++)
	{
		cin >> p[i];
	}
	createMemoandRec(L);
	cout << "最小计算结果为" << Memo[1][L]<<endl;
	printresult(1, L);
	return 0;
}
//6
//2 3 7 9 5 2 4
