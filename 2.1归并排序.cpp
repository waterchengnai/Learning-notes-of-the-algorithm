//1.归并排序解决的是具有局部有序性的排序

//举例：在举重比赛中,有四位举重运动员,他们的每人的三次举重成绩按从小到大排序好了
//那么如何将他们的12次成绩按从小到大排序呢?

//我们可以进行两两归并,比如先拿出前两人的成绩
//125 130 132		123 127 129
//然后对两个数组各自创立一个指针指向首元素
//然后进行大小比较,小的对应放进另一个数组中,且指针后移一位,如此循环
//就能得到两人的成绩排序

//同理对另外两人的成绩也这样操作,最后再把得到的两个大数组操作
//最后就得到四人的成绩排序

//2.提问?
//假如我不进行两两比较,得到的大数组再与其他数组比较如何呢?
//经实践发现,这种操作在数组越来越多的情况下比较次数明显多于两两比较

//*****************************//
//3.虽然这个例子是局部有序的
//但是大部分的输入是①完整的数组输入,并非几个分开输入②没有局部有序性
//那么我们怎么解决这个问题呢?
//我们可以把这个数组一直分,直到每个小数组都只含一个元素,这样就有局部有序性了
//然后我们再进行比较并排序,最终又回归到一个大数组

//算法流程:
//将数组A[1, n]排序问题分解为A[1, n/2]和A[n/2+1, n]排序问题(这里的n/2是取整的)
//递归解决子问题得到两个有序的子数组
//将两个有序子数组合并为一个有序数组
//归井排序 : 分解数组，递归求解，合并排序
//所以归并排序就是递归+合并+排序

//4.时间复杂度的计算
//根据计算,该算法的时间复杂度为nlogn
//怎么计算呢?
//我们已知T(n)=①2T(n/2)+O(n);②O(1)
//2T(n/2)反应的是递归将两个大数组拆成了两个小数组
//O(n)反应的是比较排序
//要计算这个递归式,我们可以用  <递归树>  来计算
//首先将树的根写作T(n),然后将他的两个根写作T(n/2),同时将根节点更新为O(n);
//那这样一棵树的所有节点之和就是T(n)
//那么我们继续将这棵树分解直到最后叶子节点为O(1)
//且我们能发现,每一行的时间复杂度加起来都是n
//那么求解时间复杂度就只需要算出有多少行
//根据二叉树的特性可知,2^k=n,即k=log(2)n;
//所以时间复杂度为nlogn.

//5.这里我们再引入分而治之的思想
//分解原问题		原问题分解成多个子问题
//解决子问题		递归地求解各个子问题
//合井问题解		将结果合井为原问题解


